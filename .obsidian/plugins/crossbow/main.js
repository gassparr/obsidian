/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CrossbowPlugin
});
module.exports = __toCommonJS(main_exports);

// src/view/view.ts
var import_obsidian2 = require("obsidian");

// src/view/treeItem.ts
var import_obsidian = require("obsidian");
var registerTreeItemElements = () => {
  TreeItem.register();
  TreeItemLeaf.register();
};
var TreeItemLeaf = class extends HTMLElement {
  constructor(value) {
    super();
    this.buttons = [];
    this.value = value;
    this.addClass("tree-item");
    this.mainWrapper = this.createDiv({
      cls: "tree-item-self is-clickable"
    });
    this.inner = this.mainWrapper.createDiv({
      cls: "tree-item-inner tree-item-inner-extensions",
      text: this.text
    });
    this.flairWrapper = this.mainWrapper.createDiv({
      cls: "tree-item-flair-outer"
    });
    this.suffix = this.inner.createEl("span", {
      cls: "tree-item-inner-suffix"
    });
    this.flair = this.flairWrapper.createEl("span", {
      cls: "tree-item-flair"
    });
  }
  get hash() {
    return this.value.hash;
  }
  get text() {
    return this.value.text;
  }
  static register() {
    customElements.define("crossbow-tree-item-leaf", TreeItemLeaf);
  }
  setDisable() {
    this.mainWrapper.style.textDecoration = "line-through";
    this.buttons.forEach((button) => button.setDisabled(true));
  }
  addOnClick(listener) {
    this.mainWrapper.addEventListener("click", listener);
  }
  addFlair(text) {
    this.flair.innerText = text;
  }
  addTextSuffix(text) {
    this.suffix.innerText = text;
  }
  addButton(label, iconName, onclick) {
    const button = new import_obsidian.ButtonComponent(this.mainWrapper);
    button.setTooltip(label);
    button.setIcon(iconName);
    button.setClass("tree-item-button");
    button.onClick(onclick);
    this.buttons.push(button);
  }
};
var TreeItem = class extends TreeItemLeaf {
  constructor(value, childrenFactory) {
    super(value);
    this.childrenFactory = null;
    this.childrenFactory = childrenFactory;
    this.addClass("is-collapsed");
    this.mainWrapper.addClass("mod-collapsible");
    this.childrenWrapper = this.createDiv({ cls: "tree-item-children" });
    this.childrenWrapper.style.display = "none";
    this.iconWrapper = this.createDiv({
      cls: ["tree-item-icon", "collapse-icon"]
    });
    this.iconWrapper.appendChild((0, import_obsidian.getIcon)("right-triangle"));
    this.appendChild(this.childrenWrapper);
    this.mainWrapper.prepend(this.iconWrapper);
    this.mainWrapper.addEventListener("click", () => this.isCollapsed() ? this.expand() : this.collapse());
  }
  static register() {
    customElements.define("crossbow-tree-item", TreeItem);
  }
  isCollapsed() {
    return this.hasClass("is-collapsed");
  }
  expand() {
    if (this.childrenFactory) {
      this.addTreeItems(this.childrenFactory(this));
      this.childrenFactory = null;
    }
    this.removeClass("is-collapsed");
    this.childrenWrapper.style.display = "block";
  }
  collapse() {
    this.addClass("is-collapsed");
    this.childrenWrapper.style.display = "none";
  }
  setDisable() {
    super.setDisable();
    this.mainWrapper.style.textDecoration = "line-through";
    this.buttons.forEach((button) => button.disabled = true);
    this.getTreeItems().forEach((child) => child.setDisable());
  }
  addTreeItems(children) {
    this.childrenWrapper.replaceChildren(...children);
  }
  getTreeItems() {
    return Array.from(this.childrenWrapper.children);
  }
};

// src/view/treeItemBuilder.ts
var CrossbowTreeItemBuilder = class {
  static createSuggestionTreeItem(suggestion, markdownLinkGenerator, targetEditor) {
    const lazySuggestionChildrenBuilder = () => CrossbowTreeItemBuilder.createOccurrenceTreeItems(suggestion, markdownLinkGenerator, targetEditor);
    const suggestionTreeItem = new TreeItem(suggestion, lazySuggestionChildrenBuilder);
    const ranks = /* @__PURE__ */ new Set();
    suggestion.matches.forEach((match) => ranks.add(match.cacheMatch.rank));
    const availableMatchRanks = Array.from(ranks).sort((a, b) => a.codePointAt(0) - b.codePointAt(0)).join("");
    suggestionTreeItem.addFlair(availableMatchRanks);
    suggestionTreeItem.addTextSuffix(`(${suggestion.occurrences.length.toString()})`);
    return suggestionTreeItem;
  }
  static createOccurrenceTreeItems(suggestion, markdownLinkGenerator, targetEditor) {
    return suggestion.occurrences.map((occurrence) => {
      const occurrenceEnd = {
        ch: occurrence.editorPosition.ch + suggestion.word.length,
        line: occurrence.editorPosition.line
      };
      const lazyOccurrenceChildrenBuilder = (self) => CrossbowTreeItemBuilder.createMatchTreeItems(suggestion.word, self, occurrenceEnd, markdownLinkGenerator, targetEditor);
      const occurrenceTreeItem = new TreeItem(occurrence, lazyOccurrenceChildrenBuilder);
      const scrollIntoView = () => {
        targetEditor.setSelection(occurrence.editorPosition, occurrenceEnd);
        targetEditor.scrollIntoView({ from: occurrence.editorPosition, to: occurrenceEnd }, true);
      };
      occurrenceTreeItem.addButton("Scroll into View", "lucide-scroll", (ev) => {
        scrollIntoView();
        ev.preventDefault();
        ev.stopPropagation();
      });
      occurrenceTreeItem.addOnClick(() => {
        if (!occurrenceTreeItem.isCollapsed())
          scrollIntoView();
      });
      return occurrenceTreeItem;
    });
  }
  static createMatchTreeItems(word, occurrenceTreeItem, occurrenceEnd, markdownLinkGenerator, targetEditor) {
    return occurrenceTreeItem.value.matches.map((match) => {
      const matchTreeItem = new TreeItemLeaf(match);
      const link = match.cacheMatch.item ? markdownLinkGenerator.generateMarkdownLink(match.cacheMatch.file, match.cacheMatch.text, "#" + match.cacheMatch.text, word) : markdownLinkGenerator.generateMarkdownLink(match.cacheMatch.file, match.cacheMatch.text, void 0, word);
      matchTreeItem.addButton("Use", "lucide-inspect", () => {
        occurrenceTreeItem.setDisable();
        targetEditor.replaceRange(link, occurrenceTreeItem.value.editorPosition, occurrenceEnd);
      });
      matchTreeItem.addButton("Go To Source", "lucide-search", () => {
        console.warn("\u{1F3F9}: 'Go To Source' is not yet implemented");
      });
      matchTreeItem.addTextSuffix(match.cacheMatch.type);
      return matchTreeItem;
    });
  }
};

// src/view/view.ts
var _CrossbowView = class extends import_obsidian2.ItemView {
  constructor(leaf) {
    super(leaf);
    this.contentEl.createSpan({ text: "Open a note to run crossbow", cls: "crossbow-view-empty" });
  }
  getViewType() {
    return _CrossbowView.viewType;
  }
  getDisplayText() {
    return "Crossbow";
  }
  getIcon() {
    return "crossbow";
  }
  load() {
    super.load();
    this.navigation = false;
  }
  clear() {
    this.contentEl.empty();
  }
  getCurrentSuggestions() {
    return this.contentEl.children.length > 0 ? Array.from(this.contentEl.children) : [];
  }
  updateSuggestions(suggestions, targetEditor, fileHasChanged) {
    CrossbowPlugin.debugLog(`${fileHasChanged ? "Clearing & adding" : "Updating"} suggestions`);
    if (fileHasChanged) {
      this.clear();
    }
    const currentSuggestionTreeItems = this.getCurrentSuggestions();
    suggestions.forEach((suggestion) => {
      const index = currentSuggestionTreeItems.findIndex((item) => item.hash === suggestion.hash);
      const existingSuggestion = index !== -1 ? currentSuggestionTreeItems.splice(index, 1)[0] : void 0;
      const suggestionTreeItem = CrossbowTreeItemBuilder.createSuggestionTreeItem(suggestion, this.app.fileManager, targetEditor);
      if (existingSuggestion) {
        const expandedOccurrencesHashes = existingSuggestion.getTreeItems().filter((item) => !item.isCollapsed()).map((item) => item.hash);
        suggestionTreeItem.getTreeItems().forEach((occurrence) => {
          if (expandedOccurrencesHashes.includes(occurrence.hash)) {
            occurrence.expand();
          }
        });
        this.contentEl.insertAfter(suggestionTreeItem, existingSuggestion);
        existingSuggestion.isCollapsed() ? suggestionTreeItem.collapse() : suggestionTreeItem.expand();
        existingSuggestion.remove();
      } else {
        const index2 = currentSuggestionTreeItems.findIndex((item) => suggestion.hash.localeCompare(item.hash) < 0);
        if (index2 === -1) {
          this.contentEl.appendChild(suggestionTreeItem);
        } else {
          this.contentEl.insertBefore(suggestionTreeItem, currentSuggestionTreeItems[index2]);
        }
      }
    });
    currentSuggestionTreeItems.forEach((item) => item.remove());
  }
};
var CrossbowView = _CrossbowView;
CrossbowView.viewType = "crossbow-toolbar";

// src/icons.ts
var import_obsidian3 = require("obsidian");
var crossbowIcon = {
  name: "crossbow",
  svg: `
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.002 512.002" xmlns:v="https://vecta.io/nano" fill="currentColor">
    <path d="M505.753 354.901l-15.083-15.083c-19.702-19.702-49.044-23.859-72.839-12.5l-43.878-43.878-13.906-208.61 23.327-23.327c8.331-8.331 8.331-21.839 0-30.17s-21.839-8.331-30.17 0l-30.165 30.165c-16.716 16.716-68.646 36.398-92.869 41.533-11.745 2.518-23.28 6.645-34.556 12.071l-53.605-53.605c-8.332-8.332-21.842-8.331-30.173.003l-15.08 15.086-23.91-23.91h8.819c11.782 0 21.333-9.551 21.333-21.333S93.447.01 81.665.01H21.513a21.41 21.41 0 0 0-4.441.428c-.103.021-.201.052-.304.074-.578.126-1.152.268-1.72.442-.134.041-.263.094-.395.138-.528.174-1.054.358-1.57.575-.12.05-.234.111-.353.164-.517.228-1.029.467-1.53.737-.091.049-.177.107-.268.158-.511.285-1.017.584-1.509.916-.061.041-.116.088-.177.13-1.052.726-2.061 1.54-2.996 2.476-.885.885-1.655 1.838-2.351 2.826-.09.127-.189.245-.275.374-.281.418-.53.849-.779 1.282-.099.172-.208.336-.302.511-.218.406-.407.822-.597 1.238-.101.221-.212.435-.306.66-.161.389-.295.785-.432 1.18-.093.266-.197.527-.279.798-.117.384-.204.773-.299 1.162-.071.291-.154.577-.213.872-.086.431-.14.866-.199 1.301-.035.258-.086.511-.111.771-.07.703-.107 1.409-.107 2.114v60.335c0 11.782 9.551 21.333 21.333 21.333s21.333-9.551 21.333-21.333v-8.836L66.591 96.76l-15.086 15.091c-8.329 8.332-8.327 21.838.003 30.168l53.066 53.062c-4.78 9.663-8.35 19.301-10.444 28.877a92.9 92.9 0 0 0-1.378 7.89c-1.967 15.328-24.484 74.421-41.245 91.182l-30.165 30.165c-8.331 8.331-8.331 21.839 0 30.17s21.839 8.331 30.17 0l23.318-23.318 208.628 13.906 43.863 43.86c-11.366 23.793-7.209 53.155 12.495 72.859l15.083 15.083c8.331 8.331 21.839 8.331 30.17 0l120.683-120.683c8.332-8.332 8.332-21.84.001-30.171zM158.582 188.747c2.639-3.559 5.336-6.989 8.038-10.208 2.747-3.272 4.819-5.561 5.868-6.653.571-.543 2.88-2.632 6.269-5.428 3.156-2.604 6.54-5.211 10.105-7.768l148.811 148.811.018.018 47.378 47.378-30.161 30.161-196.326-196.311zm80.484-53.987c7.095-1.504 28.104-7.881 46.173-14.729 12.532-4.75 23.942-9.708 34.064-14.941l8.834 132.535-99.868-99.868c3.626-1.223 7.23-2.232 10.797-2.997zm-127.433-22.707c.072-.07.15-.129.221-.2s.131-.151.202-.223l14.871-14.876 31.395 31.395c-6.755 5.127-12.201 9.867-16.113 13.686-4.056 4.209-8.919 9.76-14.107 16.434L96.761 126.93l14.872-14.877zm-6.789 207.232c15.579-29.378 28.148-65.788 30.226-81.986.174-1.348.423-2.765.743-4.228a64.51 64.51 0 0 1 1.427-5.328l100.401 100.394-132.797-8.852zm265.141 141.214c-8.315-8.317-8.325-21.807-.035-30.139.015-.015.032-.028.047-.043l60.331-60.331c.013-.013.024-.028.037-.041a21.35 21.35 0 0 1 30.132.041l-90.512 90.513z"/>
  </svg>
  `
};
var registerCrossbowIcons = () => {
  (0, import_obsidian3.addIcon)(crossbowIcon.name, crossbowIcon.svg);
};

// src/main.ts
var import_obsidian6 = require("obsidian");

// src/settings.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_SETTINGS = {
  ignoredWordsCaseSensisitve: ["image", "the", "always", "some"],
  suggestInSameFile: false,
  ignoreSuggestionsWhichStartWithLowercaseLetter: true,
  ignoreOccurrencesWhichStartWithLowercaseLetter: false,
  minimumSuggestionWordLength: 3,
  useLogging: false
};
var CrossbowSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.updateSettingValue = async (key, value) => {
      CrossbowPlugin.settings[key] = value;
      await this.plugin.saveSettings();
      this.plugin.runWithCacheUpdate(true);
    };
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Crossbow Settings \u{1F3F9}" });
    new import_obsidian4.Setting(containerEl).setName("Ignored Words").setDesc("A case-sensitive, comma separated list of words to ignore when searching for items (Headers, tags). (Whitepaces will be trimmed)").addTextArea((textArea) => {
      var _a, _b;
      textArea.setValue((_b = (_a = CrossbowPlugin.settings.ignoredWordsCaseSensisitve) == null ? void 0 : _a.join(", ")) != null ? _b : "").onChange(async (value) => await this.updateSettingValue("ignoredWordsCaseSensisitve", value.split(",").map((word) => word.trim())));
      textArea.inputEl.setAttr("style", "height: 10vh; width: 25vw;");
    });
    new import_obsidian4.Setting(containerEl).setName("Ignore suggestions which start with a lowercase letter").setDesc("If checked, suggestions which start with a lowercase letter will be ignored").addToggle((toggle) => toggle.setValue(CrossbowPlugin.settings.ignoreSuggestionsWhichStartWithLowercaseLetter).onChange(async (value) => await this.updateSettingValue("ignoreSuggestionsWhichStartWithLowercaseLetter", value)));
    new import_obsidian4.Setting(containerEl).setName("Ignore occurrences which start with a lowercase letter").setDesc("If checked, occurrences (Words in the active editor) which start with a lowercase letter will be ignored").addToggle((toggle) => toggle.setValue(CrossbowPlugin.settings.ignoreOccurrencesWhichStartWithLowercaseLetter).onChange(async (value) => await this.updateSettingValue("ignoreOccurrencesWhichStartWithLowercaseLetter", value)));
    new import_obsidian4.Setting(containerEl).setName("Make suggestions to items in the same file").setDesc("If checked, suggestions to items (Headers, Tags) in the same file be created").addToggle((toggle) => toggle.setValue(CrossbowPlugin.settings.suggestInSameFile).onChange(async (value) => await this.updateSettingValue("suggestInSameFile", value)));
    new import_obsidian4.Setting(containerEl).setName("Minimum word length of suggestions").setDesc("Defines the min. length an item (Header, Tag) must have for it to be considered a suggestion").addSlider((slider) => {
      slider.setLimits(1, 20, 1).setValue(CrossbowPlugin.settings.minimumSuggestionWordLength).onChange(async (value) => await this.updateSettingValue("minimumSuggestionWordLength", value)).setDynamicTooltip();
    });
    new import_obsidian4.Setting(containerEl).setName("Enable logging").setDesc("If checked, debug logs will be printed to the console").addToggle((toggle) => toggle.setValue(CrossbowPlugin.settings.useLogging).onChange(async (value) => await this.updateSettingValue("useLogging", value)));
  }
};

// src/editorExtension.ts
var import_obsidian5 = require("obsidian");

// src/util.ts
function stripMarkdown(md, options) {
  options = options || {};
  options.listUnicodeChar = options.hasOwnProperty("listUnicodeChar") ? options.listUnicodeChar : void 0;
  options.stripListLeaders = options.hasOwnProperty("stripListLeaders") ? options.stripListLeaders : true;
  options.gfm = options.hasOwnProperty("gfm") ? options.gfm : true;
  options.useImgAltText = options.hasOwnProperty("useImgAltText") ? options.useImgAltText : true;
  options.abbr = options.hasOwnProperty("abbr") ? options.abbr : void 0;
  options.replaceLinksWithUrl = options.hasOwnProperty("replaceLinksWithURL") ? options.replaceLinksWithUrl : true;
  options.htmlTagsToSkip = options.hasOwnProperty("htmlTagsToSkip") ? options.htmlTagsToSkip : [];
  var output = md || "";
  output = output.replace(/^(-\s*?|\*\s*?|_\s*?){3,}\s*/gm, "");
  try {
    if (options.stripListLeaders) {
      if (options.listUnicodeChar)
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, options.listUnicodeChar + " $1");
      else
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, "$1");
    }
    if (options.gfm) {
      output = output.replace(/\n={2,}/g, "\n").replace(/~{3}.*\n/g, "").replace(/~~/g, "").replace(/`{3}.*\n/g, "");
    }
    if (options.abbr) {
      output = output.replace(/\*\[.*\]:.*\n/, "");
    }
    output = output.replace(/<[^>]*>/g, "");
    var htmlReplaceRegex = new RegExp("<[^>]*>", "g");
    if (options.htmlTagsToSkip.length > 0) {
      var joinedHtmlTagsToSkip = "(?!" + options.htmlTagsToSkip.join("|") + ")";
      htmlReplaceRegex = new RegExp("<" + joinedHtmlTagsToSkip + "[^>]*>", "ig");
    }
    output = output.replace(htmlReplaceRegex, "").replace(/^[=\-]{2,}\s*$/g, "").replace(/\[\^.+?\](\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "").replace(/\!\[(.*?)\][\[\(].*?[\]\)]/g, options.useImgAltText ? "$1" : "").replace(/\[([^\]]*?)\][\[\(].*?[\]\)]/g, options.replaceLinksWithUrl ? "$2" : "$1").replace(/^\s{0,3}>\s?/gm, "").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "").replace(/^(\n)?\s{0,}#{1,6}\s+| {0,}(\n)?\s{0,}#{0,} #{0,}(\n)?\s{0,}$/gm, "$1$2$3").replace(/([\*]+)(\S)(.*?\S)??\1/g, "$2$3").replace(/(^|\W)([_]+)(\S)(.*?\S)??\2($|\W)/g, "$1$3$4$5").replace(/(`{3,})(.*?)\1/gm, "$2").replace(/`(.+?)`/g, "$1").replace(/~(.*?)~/g, "$1");
  } catch (e) {
    console.error(e);
    return md;
  }
  return output;
}

// src/editorExtension.ts
import_obsidian5.Editor.prototype.getWordLookup = function() {
  const plainText = this.getValue();
  const words = [];
  for (let i = 0; i < plainText.length; i++) {
    if (plainText[i].match(/\s/))
      continue;
    else {
      let word = "";
      let pos = this.offsetToPos(i);
      while (plainText[i] && !plainText[i].match(/\s/))
        word += plainText[i++];
      words.push({ word, pos });
    }
  }
  const filteredWords = words.filter((w) => {
    if (w.word.length <= 0)
      return false;
    if (w.word.startsWith("[[") && w.word.endsWith("]]"))
      return false;
    if (w.word.startsWith("#"))
      return false;
    return true;
  });
  const wordLookup = {};
  for (let i = 0; i < filteredWords.length; i++) {
    const word = stripMarkdown(filteredWords[i].word);
    if (filteredWords[i].word.startsWith("[[")) {
      while (!filteredWords[++i].word.endsWith("]]") || i >= filteredWords.length) {
      }
    }
    if (word in wordLookup)
      wordLookup[word].push(filteredWords[i].pos);
    else
      wordLookup[word] = [filteredWords[i].pos];
  }
  return wordLookup;
};

// src/suggestion.ts
var Suggestion = class {
  constructor(word, occurrences) {
    this.word = word;
    this.occurrences = occurrences;
  }
  get hash() {
    return this.word;
  }
  get text() {
    return this.word;
  }
  get matches() {
    return this.occurrences[0].matches;
  }
  sortChildren() {
    this.occurrences.sort((a, b) => a.editorPosition.line - b.editorPosition.line).forEach((occ) => occ.sortChildren());
  }
};
var Occurrence = class {
  constructor(editorPosition, matches) {
    this.editorPosition = editorPosition;
    this.matches = matches;
  }
  get hash() {
    return `${this.editorPosition.line}:${this.editorPosition.ch}`;
  }
  get text() {
    return `On line ${this.editorPosition.line}:${this.editorPosition.ch}`;
  }
  sortChildren() {
    this.matches.sort((a, b) => a.cacheMatch.rank.codePointAt(0) - b.cacheMatch.rank.codePointAt(0));
  }
};
var Match = class {
  constructor(cacheMatch) {
    this.cacheMatch = cacheMatch;
  }
  get hash() {
    return `${this.cacheMatch.text}|${this.cacheMatch.file.path}`;
  }
  get text() {
    return `${this.cacheMatch.rank} ${this.cacheMatch.text}`;
  }
  sortChildren() {
  }
};

// src/main.ts
var CrossbowPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.crossbowCache = {};
    this.onMetadataChange = (file, data, cache) => {
      if (this.metadataChangedTimeout)
        clearTimeout(this.metadataChangedTimeout);
      if (!this.doesCrossbowViewExist())
        return;
      this.metadataChangedTimeout = setTimeout(() => {
        this.updateCrossbowCacheEntitiesOfFile(file, cache);
        this.runWithoutCacheUpdate(false);
        CrossbowPlugin.debugLog(`Metadata cache updated for ${file.basename}.`);
      }, 2600);
    };
    this.onFileOpen = () => {
      if (!this.doesCrossbowViewExist())
        return;
      const prevCurrentFile = this._currentFile;
      this.setActiveFile();
      CrossbowPlugin.debugLog("File opened.");
      if (this.fileOpenTimeout)
        clearTimeout(this.fileOpenTimeout);
      this.fileOpenTimeout = setTimeout(() => {
        if (!prevCurrentFile)
          this.runWithCacheUpdate(true);
        else if (this._currentFile !== prevCurrentFile)
          this.runWithoutCacheUpdate(true);
      }, 100);
    };
  }
  get currentFile() {
    return this._currentFile;
  }
  static debugLog(message) {
    CrossbowPlugin.settings.useLogging && console.log(`\u{1F3F9}: ${message}`);
  }
  async onload() {
    await this.loadSettings();
    registerCrossbowIcons();
    registerTreeItemElements();
    this.registerView(CrossbowView.viewType, (leaf) => new CrossbowView(leaf));
    this.addRibbonIcon("crossbow", "Crossbow", async (ev) => {
      const existing = this.app.workspace.getLeavesOfType(CrossbowView.viewType);
      if (existing.length) {
        this.app.workspace.revealLeaf(existing[0]);
        return;
      }
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: CrossbowView.viewType,
        active: true
      });
      this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(CrossbowView.viewType)[0]);
      this.setActiveFile();
      this.runWithCacheUpdate(true);
    });
    this.addSettingTab(new CrossbowSettingTab(this.app, this));
    this.registerEvent(this.app.workspace.on("file-open", this.onFileOpen));
    this.registerEvent(this.app.metadataCache.on("changed", this.onMetadataChange));
    CrossbowPlugin.debugLog("Crossbow is ready.");
  }
  onunload() {
    var _a;
    Object.assign(this.crossbowCache, {});
    (_a = this.getCrossbowView()) == null ? void 0 : _a.unload();
    CrossbowPlugin.debugLog("Unloaded Crossbow.");
  }
  async loadSettings() {
    CrossbowPlugin.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(CrossbowPlugin.settings);
  }
  runWithCacheUpdate(fileHasChanged) {
    const files = this.app.vault.getFiles();
    files.forEach((file) => this.updateCrossbowCacheEntitiesOfFile(file));
    this.runWithoutCacheUpdate(fileHasChanged);
  }
  runWithoutCacheUpdate(fileHasChanged) {
    var _a, _b;
    const targetEditor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!targetEditor)
      return;
    const data = this.getSuggestionsInEditor(targetEditor);
    (_b = this.getCrossbowView()) == null ? void 0 : _b.updateSuggestions(data, targetEditor, fileHasChanged);
  }
  doesCrossbowViewExist() {
    return this.app.workspace.getLeavesOfType(CrossbowView.viewType).length > 0;
  }
  getCrossbowView() {
    var _a;
    return (_a = app.workspace.getLeavesOfType(CrossbowView.viewType)[0]) == null ? void 0 : _a.view;
  }
  addOrUpdateCacheEntity(entity) {
    this.crossbowCache[entity.text] = entity;
  }
  getSuggestionsInEditor(targetEditor) {
    const result = [];
    if (!targetEditor)
      return result;
    const wordLookup = targetEditor.getWordLookup();
    if (!wordLookup)
      return result;
    Object.entries(wordLookup).forEach((entry) => {
      const [word, editorPositions] = entry;
      const matchSet = /* @__PURE__ */ new Set();
      Object.keys(this.crossbowCache).forEach((cacheKey) => {
        const lowercaseWord = word.toLowerCase();
        const lowercaseCacheKey = cacheKey.toLowerCase();
        if (!CrossbowPlugin.settings.suggestInSameFile && this.crossbowCache[cacheKey].file === this._currentFile)
          return;
        if (cacheKey === word) {
          matchSet.add({ ...this.crossbowCache[cacheKey], rank: "\u{1F3C6}" });
          return;
        }
        if (CrossbowPlugin.settings.ignoredWordsCaseSensisitve.includes(word))
          return;
        if (word.length <= 3)
          return;
        if (cacheKey.length <= CrossbowPlugin.settings.minimumSuggestionWordLength)
          return;
        if ((lowercaseCacheKey.includes(lowercaseWord) || lowercaseWord.includes(lowercaseCacheKey)) === false)
          return;
        if (CrossbowPlugin.settings.ignoreOccurrencesWhichStartWithLowercaseLetter && cacheKey[0] === lowercaseCacheKey[0])
          return;
        if (CrossbowPlugin.settings.ignoreSuggestionsWhichStartWithLowercaseLetter && word[0] === lowercaseWord[0])
          return;
        if (lowercaseCacheKey === lowercaseWord) {
          matchSet.add({ ...this.crossbowCache[cacheKey], rank: "\u{1F947}" });
          return;
        }
        if (1 / cacheKey.length * word.length <= 0.2) {
          matchSet.add({ ...this.crossbowCache[cacheKey], rank: "\u{1F949}" });
          return;
        }
        matchSet.add({ ...this.crossbowCache[cacheKey], rank: "\u{1F948}" });
      });
      if (matchSet.size > 0) {
        const matches = Array.from(matchSet).map((m) => new Match(m));
        const occurrences = editorPositions.map((p) => new Occurrence(p, matches));
        result.push(new Suggestion(word, occurrences));
      }
    });
    result.sort((a, b) => a.hash.localeCompare(b.hash)).forEach((suggestion) => suggestion.sortChildren());
    return result;
  }
  updateCrossbowCacheEntitiesOfFile(file, cache) {
    if (file.extension !== "md")
      return;
    const metadata = cache ? cache : app.metadataCache.getFileCache(file);
    if (file.basename.length >= CrossbowPlugin.settings.minimumSuggestionWordLength)
      this.addOrUpdateCacheEntity({ file, text: file.basename, type: "File" });
    if (metadata) {
      if (metadata.headings)
        metadata.headings.forEach((headingCache) => this.addOrUpdateCacheEntity({
          item: headingCache,
          file,
          text: headingCache.heading,
          type: "Heading"
        }));
      if (metadata.tags)
        metadata.tags.forEach((tagCache) => this.addOrUpdateCacheEntity({
          item: tagCache,
          file,
          text: tagCache.tag,
          type: "Tag"
        }));
    }
  }
  setActiveFile() {
    const leaf = this.app.workspace.getMostRecentLeaf();
    if ((leaf == null ? void 0 : leaf.view) instanceof import_obsidian6.MarkdownView) {
      this._currentFile = leaf.view.file;
    } else
      console.warn("\u{1F3F9}: Unable to determine current editor.");
  }
};
